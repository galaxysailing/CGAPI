#include "os.h"
#include "translate.h"
#include "parse.h"
#include <vector>
#include <fstream>
#include <sstream>
#include <iostream>

using namespace std;

#define CONST_PREFIX    1

static string macros = \
"#define GLSL_CODE \n" 
"#include <stdio.h> \n"
"#include <map> \n"
"#include <string> \n"
;

static string prefix = \
"using namespace glm; \n"
;

static string class_shader_code = \
"class GLSLShader: public ShaderInterface{ \n "
"public: \n"
"vec4 gl_Position; \n"
"vec4 gl_FragColor; \n"
"void set_inner_variable(int variable, data_t& data){ \n"
"    switch(variable){ \n"
"        case INNER_GL_POSITION: \n"
"            gl_Position = data.vec4_var; \n"
"            break; \n"
"        case INNER_GL_FRAGCOLOR: \n"
"            gl_FragColor = data.vec4_var; \n"
"            break; \n"
"        default: \n"
"            break; \n"
"    } \n"
"} \n"
"void get_inner_variable(int variable, data_t& data){ \n"
"    switch(variable){ \n"
"        case INNER_GL_POSITION: \n"
"            data.vec4_var = gl_Position; \n"
"            break; \n"
"        case INNER_GL_FRAGCOLOR: \n"
"            data.vec4_var = gl_FragColor; \n"
"            break; \n"
"        default: \n"
"            break; \n"
"    } \n"
"} \n"
"void set_sampler2D_callback(get_sampler2D_data_fptr func){\n "
"    get_sampler2D = func; \n "
"}\n "
;

static string postfix = \
"\n};\n"
"extern \"C\"{ \n "
"#ifdef OS_WIN \n"
"__declspec(dllexport) \n"
"#endif \n"
"ShaderInterface* create_shader_inst(){ \n "
"    ShaderInterface* ret = new GLSLShader; \n "
"    return ret; \n "
"} \n "
"#ifdef OS_WIN \n"
"__declspec(dllexport) \n"
"#endif \n"
"void destroy_shader_inst(ShaderInterface* inst){ \n "
"    delete inst; \n "
"} \n "
"} \n "
;

#if(CONST_PREFIX)
static string const_prefix = \
"#include <stdio.h> \n"
"#include <map> \n"
"#include <string> \n"
" \n"
"#if defined(__linux__) || defined(__linux) \n"
"#  define OS_LINUX \n"
"#endif \n"
" \n"
"#if !defined(SAG_COM) && (!defined(WINAPI_FAMILY) || WINAPI_FAMILY==WINAPI_FAMILY_DESKTOP_APP) && (defined(WIN64) || defined(_WIN64) || defined(__WIN64__)) \n"
"#  define OS_WIN32 \n"
"#  define OS_WIN64 \n"
"#elif !defined(SAG_COM) && (defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)) \n"
"#  if defined(WINCE) || defined(_WIN32_WCE) \n"
"#    define OS_WINCE \n"
"#  elif defined(WINAPI_FAMILY) \n"
"#    if defined(WINAPI_FAMILY_PHONE_APP) && WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP \n"
"#      define OS_WINPHONE \n"
"#      define OS_WINRT \n"
"#    elif WINAPI_FAMILY==WINAPI_FAMILY_APP \n"
"#      define OS_WINRT \n"
"#    else \n"
"#      define OS_WIN32 \n"
"#    endif \n"
"#  else \n"
"#    define OS_WIN32 \n"
"#  endif \n"
"#endif \n"
" \n"
"#if defined(OS_WIN32) || defined(OS_WIN64) || defined(OS_WINCE) || defined(OS_WINRT) \n"
"#  define OS_WIN \n"
"#endif \n"
" \n"
"typedef struct{ \n"
"    float R; \n"
"    float G; \n"
"    float B; \n"
"}COLOR_32FC3; \n"
" \n"
"typedef struct{ \n"
"    unsigned char R; \n"
"    unsigned char G; \n"
"    unsigned char B; \n"
"}COLOR_8UC3; \n"
" \n"
"typedef struct{ \n"
"    float R; \n"
"    float G; \n"
"    float B; \n"
"    float A; \n"
"}COLOR_32FC4; \n"
" \n"
"typedef struct{ \n"
"    unsigned char R; \n"
"    unsigned char G; \n"
"    unsigned char B; \n"
"    unsigned char A; \n"
"}COLOR_8UC4; \n"
" \n"
" \n"
"#define FORMAT_COLOR_32FC3  1 \n"
"#define FORMAT_COLOR_8UC3   2 \n"
"#define FORMAT_COLOR_32FC4  3 \n"
"#define FORMAT_COLOR_8UC4   4 \n"
" \n"
"#define GLM_FORCE_AVX2 \n"
"#define GLM_FORCE_INLINE \n"
"#include <glm/glm.hpp> \n"
"#include <glm/gtc/matrix_transform.hpp> \n"
"#include <glm/gtc/type_ptr.hpp> \n"
" \n"
"union data_t{ \n"
"    glm::vec2 vec2_var; \n"
"    glm::vec3 vec3_var; \n"
"    glm::vec4 vec4_var; \n"
"    glm::mat2 mat2_var; \n"
"    glm::mat3 mat3_var; \n"
"    glm::mat4 mat4_var; \n"
"    union{ \n"
"        int sampler2D_var; \n"
"        int int_var; \n"
"    }; \n"
"}; \n"
" \n"
"#define INNER_GL_POSITION   1 \n"
"#define INNER_GL_FRAGCOLOR  2 \n"
" \n"
"enum filter_type{ \n"
"    NEAREST, \n"
"    BILINEAR \n"
"}; \n"
" \n"
"typedef struct{ \n"
"    unsigned char* tex_data; \n"
"    int width; \n"
"    int height; \n"
"    int color_format; \n"
"    filter_type filter; \n"
"}sampler_data_pack; \n"
" \n"
"typedef sampler_data_pack (*get_sampler2D_data_fptr)(int texunit_id); \n"
" \n"
"class ShaderInterface{ \n"
"    public: \n"
"    virtual ~ShaderInterface(){} \n"
"    virtual void glsl_main() = 0; \n"
"    virtual void input_port(std::map<std::string, data_t>& indata) = 0; \n"
"    virtual void output_port(std::map<std::string, data_t>& outdata) = 0; \n"
"    virtual void input_uniform_dispatch(int idx, data_t& data) = 0; \n"
"    virtual data_t output_uniform_dispatch(int idx) = 0; \n"
"    virtual void set_inner_variable(int variable, data_t& data) = 0; \n"
"    virtual void get_inner_variable(int variable, data_t& data) = 0; \n"
"    virtual void set_sampler2D_callback(get_sampler2D_data_fptr func) = 0; \n"
"}; \n"
" \n"
"class GLSLShader; \n"
"typedef void (GLSLShader::*set_uniform)(data_t& var); \n"
"typedef data_t (GLSLShader::*get_uniform)(void); \n"
" \n"
"get_sampler2D_data_fptr get_sampler2D; \n"
" \n"
"class sampler2D{ \n"
"    public: \n"
"    sampler2D():loaded_texture(false){} \n"
"    bool loaded_texture; \n"
"    int texunit_id; \n"
"    int width; \n"
"    int height; \n"
"    int size; \n"
"    int color_format; \n"
"    unsigned char *data; \n"
"    filter_type filter; \n"
"    sampler2D& operator=(int val){ \n"
"        texunit_id = val; \n"
"        loaded_texture = false; \n"
"        return *this; \n"
"    } \n"
"    inline void load_texture(){ \n"
"        if (loaded_texture) \n"
"            return; \n"
"        sampler_data_pack tmp = get_sampler2D(texunit_id); \n"
"        width = tmp.width; \n"
"        height = tmp.height; \n"
"        size = width * height; \n"
"        color_format = tmp.color_format; \n"
"        data = tmp.tex_data; \n"
"        filter = tmp.filter; \n"
"        loaded_texture = true; \n"
"    } \n"
"}; \n"
" \n"
"glm::vec4 texture(sampler2D &samp, glm::vec2 &texcoord) \n"
"{ \n"
"    samp.load_texture(); \n"
"    glm::vec4 res = glm::vec4(1.0f); \n"
"    if (samp.height == 0 || samp.width == 0) \n"
"        throw std::runtime_error(\"invalid texture used in shader\\n\"); \n"
"    float tx = texcoord.x, ty = texcoord.y; \n"
"    float inv_255 = 1.0f / 255.0f; \n"
"    if(tx < 0.0f || tx >= 1.0f){ \n"
"        tx = tx - (int)tx; \n"
"        if(tx < 0.0f){ \n"
"            tx += 1.0f; \n"
"        } \n"
"    } \n"
"    if(ty < 0.0f || ty >= 1.0f){ \n"
"        ty = ty - (int)ty; \n"
"        if(ty < 0.0f){ \n"
"            ty += 1.0f; \n"
"        } \n"
"    } \n"
"    int channel; \n"
"    switch (samp.color_format) { \n"
"        case FORMAT_COLOR_8UC3: \n"
"            channel = 3; \n"
"            break; \n"
"        case FORMAT_COLOR_8UC4: \n"
"            channel = 4; \n"
"            break; \n"
"        default: \n"
"            throw std::runtime_error(\"invalid color format\\n\"); \n"
"            break; \n"
"    } \n"
"    if (samp.filter == filter_type::NEAREST) \n"
"    { \n"
"        int x = tx * samp.width; \n"
"        int y = ty * samp.height; \n"
"        int index = y * samp.width + x; \n"
"        for (int i = 0; i < channel; ++i) { \n"
"            res[i] = ((float)samp.data[index * channel + i]) * inv_255; \n"
"        } \n"
"    } \n"
"    else if (samp.filter == filter_type::BILINEAR) \n"
"    { \n"
"        float x = tx * samp.width; \n"
"        float y = ty * samp.height; \n"
"        glm::vec4 u00, u01, u10, u11; \n"
"        int i00, i01, i11, i10; \n"
"        i00 = (int)y * samp.width + (int)x; \n"
"        i01 = (int)(y + 0.5f) * samp.width + (int)x; \n"
"        i10 = (int)y * samp.width + (int)(x + 0.5f); \n"
"        i11 = (int)(y + 0.5f) * samp.width + (int)(x + 0.5f); \n"
"        i01 = i00 >= samp.size ? samp.size - 1 : i00; \n"
"        i10 = i10 >= samp.size ? samp.size - 1 : i10; \n"
"        i11 = i11 >= samp.size ? samp.size - 1 : i11; \n"
"        for (int i = 0;i < channel;++i){ \n"
"            u00[i] = ((float)samp.data[i00 * channel + i]) * inv_255; \n"
"            u01[i] = ((float)samp.data[i01 * channel + i]) * inv_255; \n"
"            u10[i] = ((float)samp.data[i10 * channel + i]) * inv_255; \n"
"            u11[i] = ((float)samp.data[i11 * channel + i]) * inv_255; \n"
"        } \n"
"        float s = x - (int)x; \n"
"        float t = y - (int)y; \n"
"        glm::vec4 u0 = u00 + s * (u10 - u00); \n"
"        glm::vec4 u1 = u01 + s * (u11 - u01); \n"
"        res = u0 + t * (u1 - u0); \n"
"    } \n"
" \n"
"    return res; \n"
"} \n"
" \n"
"using namespace glm; \n"
"class GLSLShader: public ShaderInterface{ \n"
" public: \n"
"vec4 gl_Position; \n"
"vec4 gl_FragColor; \n"
"void set_inner_variable(int variable, data_t& data){ \n"
"    switch(variable){ \n"
"        case INNER_GL_POSITION: \n"
"            gl_Position = data.vec4_var; \n"
"            break; \n"
"        case INNER_GL_FRAGCOLOR: \n"
"            gl_FragColor = data.vec4_var; \n"
"            break; \n"
"        default: \n"
"            break; \n"
"    } \n"
"} \n"
"void get_inner_variable(int variable, data_t& data){ \n"
"    switch(variable){ \n"
"        case INNER_GL_POSITION: \n"
"            data.vec4_var = gl_Position; \n"
"            break; \n"
"        case INNER_GL_FRAGCOLOR: \n"
"            data.vec4_var = gl_FragColor; \n"
"            break; \n"
"        default: \n"
"            break; \n"
"    } \n"
"} \n"
"void set_sampler2D_callback(get_sampler2D_data_fptr func){ \n"
"     get_sampler2D = func; \n"
"} \n"
;
#endif

static string extract_headers(vector<string>& headers){
    buffer_t code;
    init_buffer(&code, 3000);
    for (auto it = headers.begin(); it != headers.end(); it++){
        string& s = *it;
        ifstream tmp_stream;
        tmp_stream.open(s);
        stringstream tmp_str_stream;
        tmp_str_stream << tmp_stream.rdbuf();		
        tmp_stream.close();
        // cout<<tmp_str_stream.str()<<endl;
        register_code(&code, tmp_str_stream.str().c_str());
        register_code(&code, "\n");
    }
    string ret = string(code.data);
    free_buffer(&code);
    return ret;
}

void cpp_code_generate(string& src, string& dest){
    #if (CONST_PREFIX == 0)
    vector<string> headers;
    headers.push_back(string("../src/gl/glsl/os.h"));
    headers.push_back(string("../src/gl/formats.h"));
    headers.push_back(string("../src/gl/glsl/vec_math.h"));
    headers.push_back(string("../src/gl/glsl/inner_variable.h"));
    headers.push_back(string("../src/gl/glsl/inner_support.h"));
    dest = macros + extract_headers(headers) + prefix + class_shader_code + src + postfix;
    #else
    dest = const_prefix + src + postfix;
    #endif
}

